---
url: https://zhuanlan.zhihu.com/p/635875056
title: CMake 构建 Makefile 深度解析：从底层原理到复杂项目
date: 2023-06-09 21:34:24
tag: 
banner: "https://picx.zhimg.com/v2-105bc248aa6ae0fce23df2305efa4607_720w.jpg?source=172ae18b"
banner_icon: 🔖
---
## 一、CMake 构建后的项目结构解析（Analysis of the Project Structure After CMake Build）

### 1.1 CMake 构建后的目录结构（Directory Structure After CMake Build）

CMake 构建完成后，会在项目的根目录下生成一个名为`build`的目录。这个目录是 CMake 构建过程中所有中间文件和最终生成的目标文件的存放地。下面我们将详细解析这个目录的结构。

首先，我们来看一下`build`目录的一级子目录：

*   CMakeFiles：这个目录中存放的是 CMake 在构建过程中生成的临时文件，包括编译器检查的结果、Find 模块（Find Modules）查找的结果等。这些文件主要用于 CMake 自身的需求，一般情况下，我们不需要关注这个目录的内容。
*   Testing：如果你的项目中包含了 CTest 测试，那么这个目录将会被生成。它包含了所有 CTest 测试的结果。
*   bin：这个目录中包含了所有的可执行文件（Executable Files）。如果你的 CMake 项目中包含了多个可执行文件，那么它们都会被放在这个目录中。
*   lib：这个目录中包含了所有的库文件（Library Files）。无论是静态库（Static Libraries）还是动态库（Dynamic Libraries），都会被放在这个目录中。

接下来，我们再深入到 CMakeFiles 目录中，看一下它的二级子目录：

*   project.dir：这个目录中包含了项目构建过程中的临时文件，如. o 文件和. d 文件。这些文件是编译器在编译源代码时生成的。
*   CMakeOutput.log：这个文件记录了 CMake 在配置过程中的输出信息，包括编译器检查的结果、Find 模块查找的结果等。
*   CMakeError.log：这个文件记录了 CMake 在配置过程中遇到的错误信息。

以上就是 CMake 构建后的目录结构的基本情况。在实际的项目中，可能会根据项目的具体需求，生成更多的子目录和文件。但是，这些基本的目录和文件是你在任何一个使用 CMake 构建的项目中都能看到的。

### 1.2 构建生成的文件类型及其作用（Types of Files Generated by the Build and Their Functions）

CMake 构建过程中会生成多种类型的文件，每种文件都有其特定的作用。下面我们将详细解析这些文件的类型和作用。

![](1686317664030.png)

*   CMakeFiles 目录：这个目录中存放的是 CMake 在构建过程中生成的临时文件，包括编译器检查的结果、Find 模块（Find Modules）查找的结果等。这些文件主要用于 CMake 自身的需求，一般情况下，我们不需要关注这个目录的内容。
*   project.dir 目录：这个目录中包含了项目构建过程中的临时文件，如. o 文件和. d 文件。这些文件是编译器在编译源代码时生成的。
*   CMakeOutput.log 文件：这个文件记录了 CMake 在配置过程中的输出信息，包括编译器检查的结果、Find 模块查找的结果等。
*   CMakeError.log 文件：这个文件记录了 CMake 在配置过程中遇到的错误信息。
*   Testing 目录：如果你的项目中包含了 CTest 测试，那么这个目录将会被生成。它包含了所有 CTest 测试的结果。
*   bin 目录：这个目录中包含了所有的可执行文件（Executable Files）。如果你的 CMake 项目中包含了多个可执行文件，那么它们都会被放在这个目录中。
*   lib 目录：这个目录中包含了所有的库文件（Library Files）。无论是静态库（Static Libraries）还是动态库（Dynamic Libraries），都会被放在这个目录中。

以上就是 CMake 构建过程中生成的主要文件类型及其作用。理解这些文件的作用，可以帮助我们更好地理解 CMake 的构建过程。

### 1.3 CMakeLists.txt 与生成的 Makefile 的关系（The Relationship Between CMakeLists.txt and the Generated Makefile）

在 CMake 构建系统中，CMakeLists.txt 文件和生成的 Makefile 文件之间存在着密切的关系。下面我们将详细解析这种关系。

CMakeLists.txt 是 CMake 构建系统的核心文件，它定义了项目的构建规则和依赖关系。在执行 CMake 命令时，CMake 会读取 CMakeLists.txt 文件，解析其中的构建规则和依赖关系，然后生成相应的 Makefile 文件。

Makefile 文件是由 CMake 根据 CMakeLists.txt 文件生成的，它是 Make 构建工具可以直接读取的构建脚本。Makefile 文件中包含了具体的编译命令和链接命令，以及源文件和目标文件之间的依赖关系。

在一个 CMake 项目中，通常会有多个 CMakeLists.txt 文件，每个目录下都可以有一个 CMakeLists.txt 文件。这些 CMakeLists.txt 文件中定义的构建规则和依赖关系，会被 CMake 合并到一起，生成一个或多个 Makefile 文件。

如果一个 CMake 项目中只有一个 CMakeLists.txt 文件，那么 CMake 会生成一个 Makefile 文件。如果一个 CMake 项目中有多个 CMakeLists.txt 文件，那么 CMake 会在每个 CMakeLists.txt 文件所在的目录下生成一个 Makefile 文件。这些 Makefile 文件中，顶层目录下的 Makefile 文件是主 Makefile 文件，它会调用其他目录下的 Makefile 文件。

总的来说，CMakeLists.txt 文件和生成的 Makefile 文件之间的关系是：CMakeLists.txt 文件定义了项目的构建规则和依赖关系，CMake 根据 CMakeLists.txt 文件生成 Makefile 文件，然后 Make 根据 Makefile 文件执行具体的构建任务。

## 二、深入理解 CMake 生成的 Makefile

### 2.1 Makefile 的基本结构和原理

Makefile 是 GNU make 工具的配置文件，它定义了一组规则来指定哪些文件需要被更新，以及如何更新这些文件。在 C++ 项目中，Makefile 通常用于编译源代码并生成可执行文件。

Makefile 的基本结构包括三个部分：目标（Target）、依赖（Dependencies）和命令（Commands）。

*   目标（Target）：这是需要生成的文件名。它可以是一个对象文件（Object File），也可以是一个可执行文件（Executable File）。
*   依赖（Dependencies）：这些是目标文件需要的源文件。如果任何一个依赖文件比目标文件更新，那么目标文件就需要被重新生成。
*   命令（Commands）：这些是生成目标文件所需要执行的 shell 命令。这些命令必须以 Tab 字符开始。

下面是一个简单的 Makefile 示例：

```
target: dependencies
    commands

```

在 CMake 中，CMakeLists.txt 文件中的指令会被转换为 Makefile 中的目标、依赖和命令。例如，add_executable 指令会生成一个目标，target_link_libraries 指令会生成依赖，而实际的编译和链接命令则由 CMake 自动生成。

理解 Makefile 的基本结构和原理，对于深入理解 CMake 生成的 Makefile 有着重要的作用。在下一节中，我们将进一步探讨多个 CMakeLists.txt 生成的 Makefile 的解析。

### 2.2 多个 CMakeLists.txt 生成的 Makefile 解析

在大型的 C++ 项目中，通常会有多个 CMakeLists.txt 文件，每个目录下都有一个。这种结构有助于保持项目的模块化，使得每个部分可以独立地被构建和测试。

当运行 CMake 命令时，它会首先查找根目录下的 CMakeLists.txt 文件，然后递归地处理每个子目录中的 CMakeLists.txt 文件。每个 CMakeLists.txt 文件都会生成一个对应的 Makefile。

在这个过程中，CMake 会处理 CMakeLists.txt 文件中的指令，如 add_executable、add_library、target_link_libraries 等，并将这些指令转换为 Makefile 中的目标、依赖和命令。

例如，如果我们有如下的目录结构：

```
project/
├── CMakeLists.txt
├── main.cpp
└── module/
    ├── CMakeLists.txt
    └── module.cpp

```

在根目录的 CMakeLists.txt 文件中，我们可能会有如下的指令：

```
add_executable(main main.cpp)
add_subdirectory(module)
target_link_libraries(main module)

```

在 module 目录的 CMakeLists.txt 文件中，我们可能会有如下的指令：

```
add_library(module module.cpp)

```

在这个例子中，CMake 会生成两个 Makefile，一个在 project 目录，一个在 project/module 目录。在 project 目录的 Makefile 中，会有一个名为 main 的目标，它依赖于 main.cpp 和 module 目录的 Makefile 中生成的库。在 project/module 目录的 Makefile 中，会有一个名为 module 的目标，它依赖于 module.cpp。

通过这种方式，CMake 使得每个子目录可以独立地被构建，同时也保证了整个项目的构建顺序。

### 2.3 CMake 与 Makefile 的对应关系

CMake 是一个跨平台的构建系统，它的主要任务是根据用户的需求生成适当的 Makefile 文件。CMake 通过读取 CMakeLists.txt 文件来了解用户的需求，然后生成对应的 Makefile 文件。

在 CMake 与 Makefile 之间，存在一种明确的对应关系。CMakeLists.txt 文件中的每一条指令，都会在生成的 Makefile 文件中有一个对应的表现。下面我们来看一些常见的 CMake 指令，以及它们在 Makefile 中的对应关系：

*   add_executable：这个 CMake 指令用于定义一个可执行文件的目标。在生成的 Makefile 中，这个目标会被定义为一个规则，规则的目标是可执行文件，依赖项是源文件，命令是编译命令。
*   add_library：这个 CMake 指令用于定义一个库文件的目标。在生成的 Makefile 中，这个目标也会被定义为一个规则，规则的目标是库文件，依赖项是源文件，命令是编译命令。
*   target_link_libraries：这个 CMake 指令用于定义目标的链接库。在生成的 Makefile 中，这个指令会影响到链接命令，链接命令会包含对应的库文件。
*   add_subdirectory：这个 CMake 指令用于添加子目录。在生成的 Makefile 中，这个指令会导致生成一个新的 Makefile 文件在对应的子目录中。

通过理解 CMake 与 Makefile 的对应关系，我们可以更好地理解 CMake 的工作原理，以及如何编写有效的 CMakeLists.txt 文件。在下一章节中，我们将进一步探讨 CMake 构建过程的底层原理。

## 三、CMake 构建过程的底层原理（Underlying Principles of the CMake Build Process）

### 3.1 CMake 构建过程的基本流程（Basic Flow of the CMake Build Process）

CMake 的构建过程可以分为三个主要步骤：配置（Configuration）、生成（Generation）和构建（Build）。下面我们将详细解析每个步骤。

**1、配置（Configuration）**

配置阶段是 CMake 解析 CMakeLists.txt 文件的过程。在这个阶段，CMake 会读取 CMakeLists.txt 文件，并执行其中的命令。这些命令主要用于检查系统环境（例如编译器、库等），设置构建选项，以及定义构建目标（例如库、可执行文件等）。

CMakeLists.txt 文件是 CMake 的核心，它定义了项目的构建规则和依赖关系。每个目录（包括子目录）中都可以有一个 CMakeLists.txt 文件。在配置阶段，CMake 会从顶层目录的 CMakeLists.txt 文件开始，递归地处理每个子目录中的 CMakeLists.txt 文件。

**2、生成（Generation）**

生成阶段是 CMake 根据配置阶段的结果，生成实际的构建文件的过程。这些构建文件通常是 Makefile 文件，但也可以是其他类型的构建文件，例如 Ninja 构建文件，或者 Visual Studio 项目文件，这取决于你选择的构建工具。

在生成阶段，CMake 会将 CMakeLists.txt 文件中定义的构建规则和依赖关系，转换为构建工具可以理解的形式。例如，如果你选择的构建工具是 Make，CMake 会生成 Makefile 文件。每个目录（包括子目录）中都会生成一个 Makefile 文件。

**3、构建（Build）**

构建阶段是使用构建工具（例如 Make、Ninja 或 Visual Studio）根据生成的构建文件，编译源代码并链接生成目标文件的过程。

在构建阶段，构建工具会读取生成的构建文件，按照其中定义的规则和依赖关系，执行实际的编译和链接操作。构建工具会自动处理依赖关系，确保在编译和链接一个目标文件之前，其所有依赖的目标文件都已经被正确地编译和链接。

以上就是 CMake 构建过程的基本流程。在理解了这个流程之后，我们就可以更深入地探讨 CMake 如何生成 Makefile，以及 CMake 构建过程中的关键步骤了。

### 3.2 CMake 如何生成 Makefile（How CMake Generates Makefile）

CMake 生成 Makefile 的过程是在其生成阶段完成的。这个过程主要涉及到 CMake 的核心组件——生成器（Generator）。下面我们将详细解析这个过程。

**1、选择生成器（Selecting a Generator）**

在 CMake 的生成阶段开始时，首先需要选择一个生成器。生成器是 CMake 的一个核心组件，它负责将 CMakeLists.txt 文件中的构建规则和依赖关系，转换为特定构建工具可以理解的形式。CMake 支持多种生成器，可以生成 Makefile 文件，也可以生成 Ninja 构建文件，或者 Visual Studio 项目文件等。

选择生成器的方式通常是在运行 CMake 命令时，通过 - G 选项指定。例如，如果你想生成 Unix 风格的 Makefile 文件，可以使用 "Unix Makefiles" 生成器，命令如下：

```
cmake -G "Unix Makefiles"

```

如果没有指定生成器，CMake 会选择一个默认的生成器，这个默认的生成器通常是根据你的系统环境自动选择的。

**2、生成 Makefile**

选择好生成器之后，CMake 就会开始生成 Makefile 文件。在这个过程中，CMake 会遍历项目中的每个目录（包括子目录），对每个目录中的 CMakeLists.txt 文件进行处理。

对于每个 CMakeLists.txt 文件，CMake 会解析其中的命令，根据这些命令定义的构建规则和依赖关系，生成对应的 Makefile 文件。每个 CMakeLists.txt 文件都会生成一个 Makefile 文件，这个 Makefile 文件中包含了编译和链接该目录中的目标文件所需要的规则和命令。

在生成 Makefile 文件时，CMake 会自动处理目标文件之间的依赖关系。如果一个目标文件依赖于其他目标文件，CMake 会在生成的 Makefile 文件中，为这个目标文件添加相应的依赖规则。

以上就是 CMake 如何生成 Makefile 的过程。理解了这个过程，我们就可以更好地理解 CMake 构建过程中的关键步骤，以及 CMake 与 Makefile 之间的关系了。

### 3.3 CMake 构建过程中的关键步骤（Key Steps in the CMake Build Process）

CMake 构建过程中的关键步骤主要包括以下几个方面：

**1、解析 CMakeLists.txt 文件（Parsing CMakeLists.txt Files）**

这是 CMake 构建过程的第一步，也是最关键的一步。CMakeLists.txt 文件是 CMake 的核心，它定义了项目的构建规则和依赖关系。CMake 需要解析这个文件，以获取构建项目所需的所有信息。

**2、检查系统环境（Checking System Environment）**

在 CMakeLists.txt 文件中，通常会包含一些检查系统环境的命令，例如检查编译器、库等。这些命令在 CMake 构建过程中会被执行，以确保系统环境满足项目的构建需求。

**3、生成构建文件（Generating Build Files）**

CMake 的主要任务是生成构建文件，这些构建文件通常是 Makefile 文件，但也可以是其他类型的构建文件，例如 Ninja 构建文件，或者 Visual Studio 项目文件，这取决于你选择的构建工具。生成构建文件的过程是 CMake 构建过程中的一个关键步骤。

**4、执行构建命令（Executing Build Commands）**

在生成了构建文件之后，就可以开始执行构建命令了。这些构建命令通常是由构建工具（例如 Make、Ninja 或 Visual Studio）执行的。构建工具会根据构建文件中定义的规则和命令，编译源代码并链接生成目标文件。

以上就是 CMake 构建过程中的关键步骤。理解了这些步骤，我们就可以更好地理解 CMake 的工作原理，以及如何使用 CMake 进行项目构建了。

## 四、CMake 在复杂项目中的应用（Application of CMake in Complex Projects）

### 4.1 复杂项目中的 CMake 构建策略（CMake Build Strategy in Complex Projects）

在复杂的项目中，CMake 的构建策略需要更加精细和周全。我们需要考虑到项目的模块化，依赖关系，以及可能存在的平台差异。以下是一些在复杂项目中使用 CMake 的策略和建议。

**4.1.1 模块化的 CMakeLists.txt（Modularized CMakeLists.txt）**

在大型项目中，我们通常会看到项目被划分为多个模块或子项目，每个模块都有自己的源代码和依赖。这种情况下，我们可以为每个模块创建一个 CMakeLists.txt 文件，这样可以使构建过程更加清晰，也方便我们管理每个模块的构建规则。

例如，我们可以在每个模块的目录下创建一个 CMakeLists.txt 文件，然后在项目的顶级目录下的 CMakeLists.txt 文件中使用 add_subdirectory() 命令来添加这些模块。

**4.1.2 管理依赖关系（Managing Dependencies）**

在复杂的项目中，不同的模块可能会有各种依赖关系。CMake 提供了一些命令来帮助我们管理这些依赖关系，例如 target_link_libraries() 命令可以用来指定一个目标需要链接的库。

在处理依赖关系时，我们需要注意的一个重要原则是：尽量让依赖关系明确和直观。这意味着，如果一个模块 A 依赖于模块 B，那么在模块 A 的 CMakeLists.txt 文件中，我们应该明确地指出这个依赖关系。

**4.1.3 处理平台差异（Handling Platform Differences）**

在跨平台的项目中，我们可能需要处理不同平台的差异。CMake 提供了一些变量和命令来帮助我们处理这些差异，例如 CMAKE_SYSTEM_NAME 变量可以用来检测当前的操作系统，if() 命令可以用来根据不同的条件执行不同的命令。

在处理平台差异时，我们应该尽量避免硬编码特定平台的信息。相反，我们应该尽可能地使用 CMake 提供的变量和命令，这样可以使我们的 CMakeLists.txt 文件更加通用和可维护。

以上就是在复杂项目中使用 CMake 的一些策略和建议。在实际应用中，我们还需要

根据项目的具体情况和需求来调整和优化我们的 CMake 构建策略。

**4.1.4 使用现代 CMake 命令（Using Modern CMake Commands）**

现代的 CMake 版本提供了一些新的命令和特性，这些命令和特性可以使我们的 CMakeLists.txt 文件更加简洁和易于理解。例如，target_include_directories() 命令可以用来指定一个目标的头文件搜索路径，这比使用旧的 include_directories() 命令更加灵活和直观。

在使用现代 CMake 命令时，我们需要注意的一个重要原则是：尽量使用目标属性（target properties）而不是全局变量（global variables）。这是因为目标属性可以使我们的 CMakeLists.txt 文件更加模块化，也更容易理解和维护。

**4.1.5 利用 CMake 的脚本功能（Leveraging CMake’s Scripting Capabilities）**

CMake 不仅是一个构建工具，它也是一种脚本语言。我们可以利用 CMake 的脚本功能来实现一些复杂的构建逻辑，例如，我们可以使用 if()、foreach() 等命令来编写循环和条件语句。

在使用 CMake 的脚本功能时，我们需要注意的一个重要原则是：尽量避免过度复杂的脚本逻辑。过度复杂的脚本逻辑可能会使我们的 CMakeLists.txt 文件难以理解和维护。相反，我们应该尽可能地使用 CMake 提供的命令和特性，这样可以使我们的 CMakeLists.txt 文件更加简洁和易于理解。

以上就是在复杂项目中使用 CMake 的一些策略和建议。在实际应用中，我们还需要根据项目的具体情况和需求来调整和优化我们的 CMake 构建策略。

### 4.2 多个 CMakeLists.txt 在复杂项目中的管理（Management of Multiple CMakeLists.txt in Complex Projects）

在大型的复杂项目中，我们通常会有多个 CMakeLists.txt 文件，每个子目录下都可能有一个。这些 CMakeLists.txt 文件共同定义了整个项目的构建规则。管理这些 CMakeLists.txt 文件是一个重要的任务，以下是一些策略和建议。

**4.2.1 模块化管理（Modular Management）**

每个 CMakeLists.txt 文件应该只负责管理其所在目录下的源代码和依赖。这样可以使每个 CMakeLists.txt 文件的内容保持简洁，也方便我们理解和维护每个模块的构建规则。

**4.2.2 统一的构建规则（Unified Build Rules）**

尽管每个 CMakeLists.txt 文件都有其自己的构建规则，但我们应该尽量使这些构建规则保持一致。这样可以使我们的构建过程更加可预测，也方便我们管理和维护我们的构建规则。

**4.2.3 利用 CMake 的包管理功能（Leveraging CMake’s Package Management Features）**

CMake 提供了一些命令和特性来帮助我们管理项目的依赖，例如 find_package() 命令可以用来查找和加载外部库。我们应该尽量利用这些命令和特性，这样可以使我们的 CMakeLists.txt 文件更加简洁，也可以避免一些常见的依赖问题。

**4.2.4 避免硬编码路径（Avoid Hard-Coded Paths）**

在 CMakeLists.txt 文件中，我们应该尽量避免硬编码路径。硬编码的路径可能会使我们的构建过程依赖于特定的目录结构，这会降低我们的构建规则的可移植性。相反，我们应该尽可能地使用 CMake 提供的变量和命令来指定路径，这样可以使我们的 CMakeLists.txt 文件更加通用和可维护。

以上就是在复杂项目中管理多个 CMakeLists.txt 文件的一些策略和建议。在实际应用中，我们还需要根据项目的具体情况和需求来调整和优化我们的管理策略。

### 4.3 CMake 在大型项目中的最佳实践（Best Practices of CMake in Large Projects）

在大型项目中使用 CMake，我们需要遵循一些最佳实践，以确保构建过程的高效、稳定和可维护。以下是一些在大型项目中使用 CMake 的最佳实践。

**4.3.1 使用最新版本的 CMake（Use the Latest Version of CMake）**

尽可能使用最新版本的 CMake。新版本的 CMake 通常会包含一些新的特性和改进，这些特性和改进可能会使我们的构建过程更加高效和稳定。此外，新版本的 CMake 也可能会修复一些旧版本中的问题和缺陷。

**4.3.2 避免在 CMakeLists.txt 文件中修改编译器标志（Avoid Modifying Compiler Flags in CMakeLists.txt Files）**

在 CMakeLists.txt 文件中直接修改编译器标志可能会导致一些问题。例如，这可能会覆盖用户在命令行中指定的编译器标志，或者导致在不同平台上的构建行为不一致。相反，我们应该使用 CMake 提供的命令和特性来管理编译器标志，例如 target_compile_options() 命令。

**4.3.3 使用 CMake 的测试功能（Use CMake’s Testing Features）**

CMake 提供了一些命令和特性来帮助我们管理和运行测试，例如 enable_testing() 命令和 add_test() 命令。我们应该尽量利用这些命令和特性，这样可以使我们的测试过程更加自动化和可控。

**4.3.4 使用 CMake 的安装功能（Use CMake’s Installation Features）**

CMake 提供了一些命令和特性来帮助我们管理项目的安装过程，例如 install() 命令。我们应该尽量利用这些命令和特性，这样可以使我们的安装过程更加自动化和可控。

以上就是在大型项目中使用 CMake 的一些最佳实践。在实际应用中，我们还需要根据项目的具体情况和需求来调整和优化我们的构建过程。

## 五、CMake 生成的 Makefile 详解

### 5.1 CMake 如何翻译生成 Makefile

在深入理解 CMake 如何翻译生成 Makefile 之前，我们首先来看一下 CMake 与 Makefile 的关系。如下图所示，CMake 通过解析 CMakeLists.txt 文件，生成对应的 Makefile，然后执行 Makefile 进行编译链接，最后生成可执行文件。

![](1686317664174.png)

CMake 的主要工作就是解析 CMakeLists.txt 文件，并将其翻译成 Makefile。CMakeLists.txt 文件是 CMake 的核心，它定义了项目的构建规则，包括项目的目录结构、需要编译的源文件、依赖关系、编译参数等信息。CMake 通过读取 CMakeLists.txt 文件，理解这些构建规则，然后生成对应的 Makefile。

在生成 Makefile 的过程中，CMake 会进行一系列的翻译操作。这些操作主要包括：

1.  **解析 CMakeLists.txt 文件**：CMake 首先会读取 CMakeLists.txt 文件，解析其中的命令和参数，理解项目的构建规则。
2.  **生成 Makefile**：根据解析得到的构建规则，CMake 会生成对应的 Makefile。这个 Makefile 包含了所有的编译链接命令，以及源文件和目标文件之间的依赖关系。
3.  **处理依赖关系**：在生成 Makefile 的过程中，CMake 会处理源文件之间的依赖关系。如果一个源文件依赖于另一个源文件，那么在 Makefile 中，这个源文件的编译命令就会依赖于另一个源文件的编译命令。
4.  **设置编译参数**：CMake 还会设置 Makefile 中的编译参数，包括编译器选项、链接器选项等。这些参数会影响到编译链接的过程。

以上就是 CMake 如何翻译生成 Makefile 的基本过程。在后续的小节中，我们将深入探讨 Makefile 的详细结构和原理，以及如何在 CMake 中使用外部 Makefile 等高级话题。

### 5.2 Makefile 的详细解析

Makefile 是由 make 工具执行的一种脚本文件，它描述了一组目标（target）以及构建这些目标所需的规则（rule）。在 CMake 生成的 Makefile 中，每一个目标通常对应一个或多个源文件，而规则则描述了如何从这些源文件生成目标。

以下是一个简单的 Makefile 示例：

```
all: hello

hello: main.o function.o
    g++ main.o function.o -o hello

main.o: main.cpp
    g++ -c main.cpp

function.o: function.cpp
    g++ -c function.cpp

clean:
    rm *.o hello

```

在这个示例中，all、hello、main.o、function.o 和 clean 都是目标，而每个目标后面的内容则是构建该目标的规则。例如，hello 目标的规则是 g++ main.o function.o -o hello，这条规则告诉 make 工具如何从 main.o 和 function.o 这两个源文件生成 hello 这个目标。

在 CMake 生成的 Makefile 中，这些规则会更加复杂，因为它们需要处理项目中的依赖关系、编译参数等问题。但是，基本的结构和原理是相同的：每个目标都有一组规则，这些规则描述了如何从源文件生成目标。

### 5.3 CMake 如何翻译生成 Makefile

当然可以，让我们更深入地探讨一些 CMake 命令和生成的 Makefile 之间的关系。

1.  add_executable：这个命令在 CMake 中用于定义一个目标可执行文件。例如，add_executable(hello main.cpp) 会定义一个名为 hello 的目标，这个目标由 main.cpp 这个源文件生成。在生成的 Makefile 中，这个命令会被翻译成一个编译命令，如 $(CXX) $(CXXFLAGS) -o hello main.cpp。这条命令告诉 make 工具使用 C++ 编译器（( C X X ) ）和编译选项（ (CXX)）和编译选项（(CXX)）和编译选项（(CXXFLAGS)）来编译 main.cpp，并将输出文件命名为 hello。
2.  add_library：这个命令在 CMake 中用于定义一个目标库文件。例如，add_library(mylib mylib.cpp) 会定义一个名为 mylib 的目标，这个目标由 mylib.cpp 这个源文件生成。在生成的 Makefile 中，这个命令会被翻译成一个库生成命令，如 $(AR) $(ARFLAGS) mylib mylib.cpp。这条命令告诉 make 工具使用库生成器（( A R ) ）和库生成选项（ (AR)）和库生成选项（(AR)）和库生成选项（(ARFLAGS)）来生成 mylib 这个库。
3.  target_link_libraries：这个命令在 CMake 中用于定义目标的链接库。例如，target_link_libraries(hello mylib) 会告诉 CMake，hello 这个目标需要链接 mylib 这个库。在生成的 Makefile 中，这个命令会被翻译成一个链接命令，如 $(CXX) $(LDFLAGS) -o hello main.cpp -lmylib。这条命令告诉 make 工具在链接 hello 时，需要链接 mylib 这个库。

以上就是 CMake 命令和生成的 Makefile 之间的一些基本关系。在实际的项目中，这些关系可能会更复杂，因为 CMake 和 Makefile 都是非常强大的工具，它们提供了许多高级功能来处理项目中的各种问题。但是，理解这些基本关系是理解 CMake 和 Makefile 的关键。

![](1686317664235.png)

### 5.4 CMake 生成的 Makefile 中的常见问题及解决方案

在使用 CMake 生成 Makefile 的过程中，可能会遇到一些常见的问题。这些问题可能涉及到 Makefile 的生成、执行、以及依赖关系的处理等方面。下面我们将详细介绍这些问题，以及相应的解决方案。

1.  Makefile 生成失败：这是一个比较常见的问题，通常是由于 CMakeLists.txt 文件中的错误导致的。解决这个问题的方法是检查 CMakeLists.txt 文件，确保其中的命令和参数都是正确的。
2.  Makefile 执行错误：这个问题通常是由于 Makefile 中的命令错误导致的。解决这个问题的方法是检查 Makefile，确保其中的编译链接命令都是正确的。
3.  依赖关系处理错误：这个问题通常是由于 CMake 处理源文件之间的依赖关系时出错导致的。解决这个问题的方法是检查 CMakeLists.txt 文件，确保其中的依赖关系都是正确的。

以上就是在使用 CMake 生成 Makefile 时可能遇到的一些常见问题，以及相应的解决方案。在实际使用中，可能还会遇到其他的问题，这时候需要根据具体的错误信息，进行相应的排查和解决。

## 六、CMake 与外部 Makefile 的交互（Interaction Between CMake and External Makefile）

### 6.1 如何在 CMake 中使用外部 Makefile（How to Use External Makefile in CMake）

在 CMake 中使用外部 Makefile，我们可以使用 add_custom_command 和 add_custom_target 这两个命令。这两个命令可以用来执行一些自定义的构建规则，比如运行一个脚本，创建一个文件，或者运行一个 Makefile。

**6.1.1 add_custom_command**

add_custom_command 命令用于定义如何生成一个文件。这个命令有很多参数，但是最常用的是 OUTPUT，COMMAND 和 DEPENDS。

*   OUTPUT 参数用于指定生成的文件。
*   COMMAND 参数用于指定生成文件的命令，可以是任何 shell 命令。
*   DEPENDS 参数用于指定生成文件所依赖的文件。

例如，我们可以使用以下命令来运行一个外部 Makefile：

```
add_custom_command(
  OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/generated_file
  COMMAND make -C ${CMAKE_CURRENT_SOURCE_DIR}/external_project
  DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/external_project/Makefile
)

```

这个命令表示，如果`generated_file`不存在，或者`external_project/Makefile`有任何改动，那么就会执行`make -C external_project`命令来生成`generated_file`。

**6.1.2 add_custom_target**

然而，add_custom_command 只有在其输出文件被其他目标使用时，才会被执行。如果我们想要在每次构建时都执行某个命令，那么我们需要使用 add_custom_target 命令。

add_custom_target 命令用于定义一个自定义的目标。这个目标不会生成任何文件，也不会在构建时自动被执行。我们需要手动执行这个目标，或者将它添加为其他目标的依赖。

例如，我们可以使用以下命令来定义一个运行外部 Makefile 的目标：

```
add_custom_target(
  run_external_makefile
  COMMAND make -C ${CMAKE_CURRENT_SOURCE_DIR}/external_project
)

```

这个命令定义了一个名为 run_external_makefile 的目标。我们可以使用 make run_external_makefile 命令来手动执行这个目标。

如果我们想要在每次构建时都执行这个目标，那么我们可以将它添加为其他目标的依赖。例如，我们可以使用以下命令来将 run_external_makefile 添加为 my_target 的依赖：

```
add_dependencies(my_target run_external_makefile)

```

这样，每次构建`my_target`时，都会先执行`run_external_makefile`目标。

以上就是如何在 CMake 中使用外部 Makefile 的基本方法。在实际使用中，我们可能需要根据具体的需求来调整这些命令的参数。

**6.1.3 add_custom_command 的其他参数**

除了`OUTPUT`，`COMMAND`和`DEPENDS`参数外，`add_custom_command`命令还有一些其他的参数，可以用来控制命令的行为。

*   WORKING_DIRECTORY 参数用于指定命令的工作目录。如果不指定这个参数，那么命令的工作目录就是当前的构建目录。
*   COMMENT 参数用于指定一个注释，这个注释会在命令执行时显示在控制台上。
*   VERBATIM 参数用于控制命令的参数是否需要转义。如果设置为 TRUE，那么命令的参数就会被转义，这样就可以安全地处理包含特殊字符的参数。

例如，我们可以使用以下命令来运行一个外部 Makefile，并显示一个注释：

```
add_custom_command(
  OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/generated_file
  COMMAND make -C ${CMAKE_CURRENT_SOURCE_DIR}/external_project
  DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/external_project/Makefile
  WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
  COMMENT "Running external Makefile"
  VERBATIM
)

```

这个命令表示，如果 generated_file 不存在，或者 external_project/Makefile 有任何改动，那么就会在 ${CMAKE_CURRENT_BINARY_DIR} 目录下执行 make -C external_project 命令来生成 generated_file，并显示 "Running external Makefile" 的注释。

以上就是在 CMake 中使用外部 Makefile 的基本方法。在实际使用中，我们可能需要根据具体的需求来调整这些命令的参数。

**6.2 外部 Makefile 如何影响 CMake 生成的 Makefile（How External Makefile Affects Makefile Generated by CMake）**

在 CMake 中，我们可以通过 add_custom_command 或 add_custom_target 命令来插入外部 Makefile，从而影响 CMake 生成的 Makefile。下面是这个过程的示意图：

![](1686317664321.png)

在这个过程中，CMake 首先解析 CMakeLists.txt 文件，生成 CMakeCache.txt 文件。然后，CMake 根据 CMakeCache.txt 文件生成 Makefile。在生成 Makefile 的过程中，CMake 会执行 add_custom_command 或 add_custom_target 命令，插入外部 Makefile。

插入外部 Makefile 的主要目的是为了增加一些自定义的构建规则。例如，我们可能需要在构建过程中执行一些特殊的命令，或者生成一些特殊的文件。通过插入外部 Makefile，我们可以在 CMake 的构建过程中执行这些自定义的构建规则。

然而，插入外部 Makefile 也可能会带来一些问题。例如，如果外部 Makefile 中的构建规则与 CMake 生成的构建规则冲突，那么可能会导致构建失败。因此，在插入外部 Makefile 时，我们需要确保外部 Makefile 中的构建规则与 CMake 生成的构建规则是兼容的。

在实际使用中，我们可能需要根据具体的需求来调整插入外部 Makefile 的方式。例如，我们可以通过修改 add_custom_command 或 add_custom_target 命令的参数，来控制外部 Makefile 的插入位置，或者控制外部 Makefile 的执行方式。

### 6.3 高级技巧：自由控制 CMake 生成规则（Advanced Techniques: Freely Control CMake Generation Rules）

CMake 提供了一系列的命令，可以用来自由控制生成规则。这些命令可以用来定义自定义的目标，添加依赖关系，设置编译选项，等等。下面我们将介绍一些高级的技巧，可以帮助你更好地控制 CMake 的生成规则。

**6.3.1 自定义目标（Custom Targets）**

在 CMake 中，我们可以使用 add_custom_target 命令来定义一个自定义的目标。这个目标不会生成任何文件，也不会在构建时自动被执行。我们需要手动执行这个目标，或者将它添加为其他目标的依赖。

例如，我们可以使用以下命令来定义一个运行外部 Makefile 的目标：

```
add_custom_target(
  run_external_makefile
  COMMAND make -C ${CMAKE_CURRENT_SOURCE_DIR}/external_project
)

```

这个命令定义了一个名为`run_external_makefile`的目标。我们可以使用`make run_external_makefile`命令来手动执行这个目标。

**6.3.2 添加依赖关系（Adding Dependencies）**

在 CMake 中，我们可以使用`add_dependencies`命令来添加目标之间的依赖关系。这个命令接受两个或更多的参数，第一个参数是目标，后面的参数是它所依赖的目标。

例如，我们可以使用以下命令来将`run_external_makefile`添加为`my_target`的依赖：

```
add_dependencies(my_target run_external_makefile)

```

这样，每次构建`my_target`时，都会先执行`run_external_makefile`目标。

**6.3.3 设置编译选项（Setting Compilation Options）**

在 CMake 中，我们可以使用`target_compile_options`命令来设置目标的编译选项。这个命令接受两个参数，第一个参数是目标，第二个参数是编译选项。

例如，我们可以使用以下命令来为`my_target`设置编译选项：

```
target_compile_options(my_target PRIVATE -Wall -Wextra)

```

这个命令会为`my_target`添加`-Wall`和`-Wextra`这两个编译选项。

以上就是在 CMake 中自由控制生成规则的一些高级技巧。在实际使用中，我们可能需要根据具体的需求来调整这些命令的参数。